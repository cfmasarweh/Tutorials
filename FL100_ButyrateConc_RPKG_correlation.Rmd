---
title: "Correlating FL100 Butyrate Pathway RPKG with Fecal Butyrate Concentration"
rmd_author: "Chad Masarweh, ChatGPT4o"
content_authors:
  - "Chad Masarweh, ChatGPT4o"
date: "2024-12-05"
output:
  html_document:
    css: "/Users/chad.masarweh/Documents/FL100_SCFA/dracula.css"
---

#### RMarkdown authors: Chad Masarweh and ChatGPT4o

#### Content authors: Chad Masarweh, ChatGPT4o, and Andrew Oliver

<br>

I calculated the RPKG of each gene in the butyrate synthesis pathways via

- merged reads against the reference database via DIAMOND
- unmerged reads against DIAMOND-annotated butyrate synthesis gene ORFs via BWA
- merged reads against DIAMOND-annotated butyrate synthesis gene ORFs via BWA
- unmerged reads against HMMER-annotated butyrate synthesis gene ORFs via BWA
- merged reads against HMMER-annotated butyrate synthesis gene ORFs via BWA

I summed the RPKG of the all the genes in each pathway, *except*

- **bcd**, **etfA**, and **etfB** in the Acetyl-CoA, Lysine, and Glutarate pathways, because those genes are common to those pathways
- **gcdB** in the Glutarate and "sumPaths2" pathways because the gene it's poorly annotated
- **gcdB**, **etfA**, and **etfB** in the "sumPaths1" pathway because **etfA** and **etfB** are common to all pathways


<br>

----

```{r setup, results='hide', message = FALSE}
data_dir = "/Users/chad.masarweh/Documents/FL100_SCFA"

library(dplyr)
library(tidyr)
library(readr)
library(ggplot2)
library(gridExtra)
library(grid)
library(rlang)
```

### Import pathway and gene RPKG files from the DIAMOND, DIAMOND->BWA, and HMMER->BWA workflows
Here, "but" refers to "butyrate", and "DIA" refers to "DIAMOND", and "merged" refers to "from merged reads", and "unmerged" refers to "from unmerged reads", and "HMMERBWA" means the workflow was "mapped reads via BWA to HMMER-annotated genes", and "DIABWA" means the workflow was "mapped reads via BWA to DIAMOND-annotated genes"

Because the pathways and genes files, respectively, are exactly the same format, they can be imported as elements of a list, over which commands can be iterated.
```{r import_data}
# Define a function to rename the first column to "subject_id", since it might be "subject"
rename_first_column <- function(df) { 
  colnames(df)[1] <- "subject_id"
  df$subject_id <- as.character(df$subject_id) 
  
  # Rename "4hbt" to "ghbt" to make R happy. "4" and "g" for "gamma" are equivalent
  if ("4hbt" %in% colnames(df)) {
    colnames(df)[colnames(df) == "4hbt"] <- "ghbt"
  }
  
  return(df) 
}

# Convert strings to NA and ensure numeric values
clean_numeric <- function(df) {
  df %>%
    mutate(across(-subject_id, ~ as.numeric(as.character(.))))
}

# Define the DIAMOND percent identity thresholds to name things and filter things
thresholds <- c(50, 60, 70, 80, 90, 95, 98, 99, 100)
thresholds2 <- c(40, 50, 60, 70, 80, 90)

# Create pathways_rpkg list with the first column renamed to "subject_id"
pathways_rpkg <- 
  c(
    setNames(
      lapply(
        sprintf(file.path(data_dir, "FL100_but_pathways_rpkg_DIA%d.tsv"), thresholds), 
        function(file) { 
          rename_first_column(read_tsv(file, show_col_types = FALSE)) 
          }
      ), 
      sprintf("d%d", thresholds)
    ),
    setNames(
      lapply(
        sprintf(file.path(data_dir, "FL100_but_pathways_unmerged_rpkg_DIA%dBWA.tsv"), thresholds2), 
        function(file) { 
          rename_first_column(read_tsv(file, show_col_types = FALSE)) 
          }
      ), 
      sprintf("d%d_b", thresholds2)
    ),
    list("hGA_b" = 
         rename_first_column(
           read_tsv(file.path(data_dir, "FL100_but_pathways_unmerged_rpkg_HMMERBWA.tsv"), 
                    show_col_types = FALSE
                    )
         )
    ),
    list("hGA_b_fs" = 
         rename_first_column(
           read_tsv(file.path(data_dir, "FL100_but_pathways_unmerged_rpkg_HMMERBWAFS.tsv"), 
                    show_col_types = FALSE
                    )
         )
    ),
    list("hGA_b_m" = 
         rename_first_column(
           read_tsv(file.path(data_dir, "FL100_but_pathways_merged_rpkg_HMMERBWA.tsv"), 
                    show_col_types = FALSE
                    )
         )
    ),
    list("d90_b_m" = 
         rename_first_column(
           read_tsv(file.path(data_dir, "FL100_but_pathways_merged_rpkg_DIA90BWA.tsv"), 
                    show_col_types = FALSE
                    )
         )
    )
  )

# Create genes_rpkg list with the first column renamed to "subject_id"
genes_rpkg <- 
  c(
    setNames(
      lapply(
        sprintf(file.path(data_dir, "FL100_but_genes_rpkg_DIA%d_collapsed.tsv"), thresholds), 
        function(file) { 
          rename_first_column(read_tsv(file, show_col_types = FALSE)) 
        }
      ), 
      sprintf("d%d", thresholds)
    ),
    setNames(
      lapply(
        sprintf(file.path(data_dir, "FL100_but_genes_unmerged_rpkg_DIA%dBWA_collapsed.tsv"), thresholds2), 
        function(file) { 
          rename_first_column(read_tsv(file, show_col_types = FALSE)) 
        }
      ), 
      sprintf("d%d_b", thresholds2)
    ),
    list("hGA_b" = 
         rename_first_column(
           read_tsv(file.path(data_dir, "FL100_but_genes_unmerged_rpkg_HMMERBWA_collapsed.tsv"), 
                    show_col_types = FALSE
                    )
         )
    ),
    list("hGA_b_fs" = 
         rename_first_column(
           read_tsv(file.path(data_dir, "FL100_but_genes_unmerged_rpkg_HMMERBWAFS_collapsed.tsv"), 
                    show_col_types = FALSE
                    )
         )
    ),
    list("hGA_b_m" = 
         rename_first_column(
           read_tsv(file.path(data_dir, "FL100_but_genes_merged_rpkg_HMMERBWA_collapsed.tsv"), 
                    show_col_types = FALSE
                    )
         )
    ),
    list("d90_b_m" = 
         rename_first_column(
           read_tsv(file.path(data_dir, "FL100_but_genes_merged_rpkg_DIA90BWA_collapsed.tsv"), 
                    show_col_types = FALSE
                    )
         )
    )
  )

# Check out the result
head(pathways_rpkg[[1]])
head(genes_rpkg[[1]])
```

### Question: do different RPKG calculation workflows produce different RPKG distributions? (very yes)
```{r}
group1 <- c("abfH", "ghbt", "abfD")
group2 <- c("kamA", "kamD", "kamE", "kdd", "kce", "kal", "atoA", "atoD")
group3 <- c("gctA", "gctB", "hgCoAdA", "hgCoAdB", "hgCoAdC", "gcdA", "gcdB")
group4 <- c("but", "buk", "ptb", "thl", "bhbd", "cro")
group5 <- c("bcd", "etfA", "etfB")

combined_df <- do.call(rbind, 
                       lapply(names(genes_rpkg), function(name) {
                         df <- genes_rpkg[[name]]
                         df$element <- name  # Add a new column to identify the pathway set
                         df
                       }
                       )
)

# Gather all variables except "subject_id" and "element" for plotting
combined_long <- combined_df %>%
  select(-subject_id) %>%  # Remove the "subject_id" column
  pivot_longer(-element, names_to = "variable", values_to = "value")  # Convert to long format

combined_long$element <- 
  factor(combined_long$element, 
         levels = c(
           "d50",
           "d60",
           "d70",
           "d80",
           "d90",
           "d95", 
           "d98", 
           "d99", 
           "d100", 
           "d40_b", 
           "d50_b", 
           "d60_b", 
           "d70_b", 
           "d80_b", 
           "d90_b", 
           "d90_b_m", 
           "hGA_b_m",
           "hGA_b",
           "hGA_b_fs"
         )
  )

combined_long$variable <- 
  factor(combined_long$variable, 
         levels = c(
           "abfH", # beginning of 4-aminobutyrate pathway
           "ghbt", 
           "abfD", 
           "kamA", # beginning of lysine pathway
           "kamD", 
           "kamE", 
           "kdd", 
           "kce", 
           "kal", 
           "atoA", 
           "atoD", 
           "gctA", # beginning of Glutarate pathway
           "gctB", 
           "hgCoAdA", 
           "hgCoAdB", 
           "hgCoAdC", 
           "gcdA", 
           "gcdB", ## note that this gene is not included in the pathway calculations
           "but", # beginning of acetyl-CoA pathway
           "buk", 
           "ptb", 
           "thl", 
           "bhbd", 
           "cro",
           "bcd", # shared genes
           "etfA", 
           "etfB"
         )
  )

separator_df <- data.frame(xintercept = which(levels(combined_long$element) == "d100") + 0.5)

# Function to generate a plot for a given group with median lines
plot_group <- function(data, group, group_title) {
  group_data <- data %>% filter(variable %in% group)
  
  # Compute the median value of "hGA_b" for each gene in the group
  median_values <- group_data %>%
    filter(element %in% c("hGA_b", "hGA_b_m")) %>%
    group_by(variable) %>%
    summarize(median_value = mean(median(value, na.rm = TRUE), na.rm = TRUE))
  
  
  ggplot(group_data, aes(x = element, y = value)) +
    geom_boxplot() +
    geom_hline(data = median_values, aes(yintercept = median_value), color = "blue", linetype = "dotted", linewidth = 1) +
    geom_vline(data = separator_df, aes(xintercept = xintercept), color = "red", linetype = "dashed", linewidth = 0.5) +
    facet_wrap(~ variable, ncol = 4, scales = "free") +
    theme_bw() +
    labs(title = group_title, x = "RPKG calculation workflow", y = "RPKG") +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, color = "black"),
      plot.title = element_text(hjust = 0.5),
      axis.title.x = element_text(face = "bold"),
      axis.title.y = element_text(face = "bold")
    )
}

# Generate plots for each group with median lines
plot1 <- plot_group(combined_long, group1, "Box-and-whisker plots for 4-Aminobutyrate pathway genes")
plot2 <- plot_group(combined_long, group2, "Box-and-whisker plots for Lysine pathway genes")
plot3 <- plot_group(combined_long, group3, "Box-and-whisker plots for Glutarate pathway genes")
plot4 <- plot_group(combined_long, group4, "Box-and-whisker plots for Acetyl-CoA pathway genes")
plot5 <- plot_group(combined_long, group5, "Box-and-whisker plots for shared pathway genes")
```
- `d90`-`d100` were created by aligning merged reads against the reference database via DIAMOND
- `d90_b` and `d30_b` were created by BWA-aligning unmerged reads against DIAMOND-annotated butyrate synthesis gene ORFs
- `d90_b_m` was created by BWA-aligning merged reads against DIAMOND-annotated butyrate synthesis gene ORFs
- `hGA_b` was created by BWA-aligning unmerged reads against `--cut-ga`-HMMER-annotated butyrate synthesis gene ORFs
- `hGA_b_fs` was created by filtering the files that made `hGA_b` by genes that were annotated by Foldseek. 
- `hGA_b_m` was created by BWA-aligning merged reads against `--cut-ga`-HMMER-annotated butyrate synthesis gene ORFs

```{r gene_rpkg_graphs, fig.width=12, fig.height=30, message=FALSE, warning=FALSE}
# Arrange the plots in a grid layout
grid.arrange(plot1, plot2, plot3, plot4, plot5, ncol = 1, heights = c(2, 2, 2, 2, 1))

```

- notice that "gcdB", of the Glutarate pathway, is way way overestimated by HMMER. This was expected, as it was pointed out by Vital, Karch, and Pieper 2017 mSystems.
- notice also that many genes are somewhat overestimated by HMMER, such that the workflow that starts with DIAMOND-annotation of ORFs is similar to the DIAMOND-annotated reads workflow. This probably explains why the trendline and correlations are negative for some pathway calculations from the HMMER workflows

### Question: do the same butyrate *pathway* RPKG measurements from different workflows correlate?
```{r w/in_thresh_reads_corr}
corr_list <- list()

# Make a vector of column names, except 'subject_id'
columns_to_corr <- setdiff(colnames(pathways_rpkg[[1]]), "subject_id")

# loop through each column name (i.e. pathway count)
for (col in columns_to_corr) {
  
  # Calculate the correlation matrix across all pathways_rpkg elements for the current column
  corr_element <- 
    cor(
      do.call(
        cbind, 
        lapply(
          names(pathways_rpkg), 
          function(element) pathways_rpkg[[element]][[col]]
        )
      ), 
      method = "spearman"
    )
  
  # The matrix has no names, only a position index. Assign row and column names based on the names of pathways_rpkg
  colnames(corr_element) <- rownames(corr_element) <- names(pathways_rpkg)
  
  # Extract the lower triangular part of the matrix (excluding the diagonal)
  corr_element[upper.tri(corr_element, diag = TRUE)] <- NA
  
  # Store the correlation matrix in the previously-defined list using the column name as element name
  corr_list[[col]] <- corr_element
}
```

Relevant lines of code from `count_ButyratePathways.py`

- pathway_rpkg['Acetyl'] = df[['bhbd', 'buk', 'but', 'cro', 'ptb', 'thl']].sum(axis=1)
- pathway_rpkg['Glut'] = df[['hgCoAdA', 'hgCoAdB', 'hgCoAdC', 'gcdA', 'gctA', 'gctB']].sum(axis=1)
- pathway_rpkg['Lys'] = df[['kamA', 'kamD', 'kamE', 'kdd', 'kce', 'kal', 'atoA', 'atoD']].sum(axis=1)
- pathway_rpkg['GABA'] = df[['ghbt', 'abfD', 'abfH']].sum(axis=1)
- pathway_rpkg['sumPaths1'] = df[['ghbt', 'abfD', 'abfH', 'kamA', 'kamD', 'kamE', 'kdd', 'kce', 'kal', 'atoA', 'atoD', 'hgCoAdA', 'hgCoAdB', 'hgCoAdC', 'gcdA', 'gctA', 'gctB', 'bhbd', 'buk', 'but', 'cro', 'ptb', 'thl', 'bcd', 'etfA', 'etfB']].sum(axis=1)
- pathway_rpkg['sumPaths2'] = df[['ghbt', 'abfD', 'abfH', 'kamA', 'kamD', 'kamE', 'kdd', 'kce', 'kal', 'atoA', 'atoD', 'hgCoAdA', 'hgCoAdB', 'hgCoAdC', 'gcdA', 'gctA', 'gctB', 'bhbd', 'buk', 'but', 'cro', 'ptb', 'thl', 'bcd']].sum(axis=1)

```{r}
for (col in names(corr_list)) {
  # Round each correlation matrix in the list to 4 decimal places (10,000th)
  corr_matrix_rounded <- round(corr_list[[col]], 2)
  
  cat(paste("Correlation matrix for", col, ":\n"))
  print(corr_matrix_rounded, na.print = "")
  cat("\n")
}

```
-   `corr_element <- cor()` will make a correlation matrix from a matrix input
-   `do.call()` accepts the list generated by `lapply()` and `cbind()`s-together each element into a matrix because `cbind()` default behavior is to create a matrix if all inputs are numeric vectors
-   `lapply(names(pathways_rpkg), function(element)` is not a loop, but iterates over each list element's pathways RPKG and returns a list, with each element representing a different calculation workflow of the current value of col
-   `method = "spearman"` based on previous analyses, i will assume the data are not normally distributed
-   `corr_element[upper.tri(corr_element, diag = TRUE)] <- NA` Because direction of correlation does matter, the matrix is a mirror

----

### Preparation of SCFA data by Andrew Oliver
```{r andrew}
path_plasma_input <- "/Users/chad.masarweh/Documents/FL100_SCFA/plasma_scfas.csv"
path_plasma_output <- "/Users/chad.masarweh/Documents/FL100_SCFA/plasma_scfas_processed.csv"
path_fecal_input <- "/Users/chad.masarweh/Documents/FL100_SCFA/fecal_scfa_fl100.csv"
path_new_but_isobut <- "/Users/chad.masarweh/Documents/FL100_SCFA/butyrate_isob_new_integration_12-06-22.csv"
path_fecal_output <- "/Users/chad.masarweh/Documents/FL100_SCFA/fecal_scfas_processed.csv"
path_fecal_vars <- "/Users/chad.masarweh/Documents/FL100_SCFA/FL100_stool_variables.txt"

`%!in%` <- Negate(`%in%`)

## read in PLASMA SCFA data
scfa_plasma <- readr::read_delim(path_plasma_input, delim = ",", col_types = "fdddf")

## any missing or NA in propionate or butyrate, make it 10
## this is because you supply 10 as the value that is left-censored in 
## censored models.
###CHAD SAYS: to deal with rank statistical tests, might want to collapse samples equal to 10 
scfa_plasma[c("p_butyric_acid", "p_propionic_acid")][is.na(scfa_plasma[c("p_butyric_acid", "p_propionic_acid")])] <- 10

## create a list of subjects whose plasma samples we have multiples of
scfa_duplicated <- scfa_plasma %>% dplyr::filter(., duplicates != "") %>% dplyr::pull(., subject_id) %>% droplevels()

## create a empty DF in which to place the average of duplicated samples
deduplicated <- data.frame(subject_id=character(), 
                           p_acetic_acid=numeric(), 
                           p_propionic_acid=numeric(),
                           p_butyric_acid=numeric())

## loop through duplicated samples
scfas <- c("p_acetic_acid", "p_propionic_acid", "p_butyric_acid")
for (subject in unique(scfa_duplicated)) {
  
  ## for each duplicated sample, pull it out and all the duplicated SCFA data
  scfa_duplicated_tmp <- scfa_plasma %>% dplyr::filter(., subject_id == subject) %>% 
    dplyr::select(., subject_id, p_acetic_acid, p_propionic_acid, p_butyric_acid)
  
  ## check and make sure you dont have a SCFA that is completely missing data
  ## you shouldnt with this data
  if (max((sum(is.na(scfa_duplicated_tmp$p_acetic_acid))), 
          (sum(is.na(scfa_duplicated_tmp$p_propionic_acid))), 
          (sum(is.na(scfa_duplicated_tmp$p_butyric_acid)))) > NROW(scfa_duplicated_tmp)) {
    stop("You have duplicated subject_id with completely missing SCFA data for at least one SCFA")
  }
  
  ## create a vector of the mean SCFA abundance of the values you have,
  ## ignoring any NAs
  missing_means <- colMeans(scfa_duplicated_tmp[2:4], na.rm = T)
  count = 1
  
  ## add this SCFA mean to the formerly empty, deduplicated DF
  deduplicated <- deduplicated %>% tibble::add_row(., subject_id=subject, 
                                                   p_acetic_acid=missing_means[1], 
                                                   p_propionic_acid=missing_means[2],
                                                   p_butyric_acid=missing_means[3])
}

## remove duplicated from raw data and add back in averaged values
scfa_plasma_dedup <- scfa_plasma %>% dplyr::select(., -duplicates) %>%
  dplyr::filter(., subject_id %!in% scfa_duplicated)
scfa_plasma_dedup <- rbind(scfa_plasma_dedup, deduplicated)

## convert ng/mL to nmole/ul because fecal units are nmole/mg
scfa_plasma_dedup$p_butyric_acid_nmol <- scfa_plasma_dedup$p_butyric_acid / (1000 * 88.11)
scfa_plasma_dedup$p_acetic_acid_nmol <- scfa_plasma_dedup$p_acetic_acid / (1000 * 60.052)
scfa_plasma_dedup$p_propionic_acid_nmol <- scfa_plasma_dedup$p_propionic_acid / (1000 * 74.08)

## total here
scfa_plasma_dedup$p_scfa_nmol_total <- scfa_plasma_dedup$p_butyric_acid_nmol + 
  scfa_plasma_dedup$p_acetic_acid_nmol + 
  scfa_plasma_dedup$p_propionic_acid_nmol

## create relative abundance values
scfa_plasma_dedup$p_butyric_acid_nmol_norm <- scfa_plasma_dedup$p_butyric_acid_nmol / scfa_plasma_dedup$p_scfa_nmol_total
scfa_plasma_dedup$p_acetic_acid_nmol_norm <- scfa_plasma_dedup$p_acetic_acid_nmol / scfa_plasma_dedup$p_scfa_nmol_total
scfa_plasma_dedup$p_propionic_acid_nmol_norm <- scfa_plasma_dedup$p_propionic_acid_nmol / scfa_plasma_dedup$p_scfa_nmol_total

## write to file
#readr::write_delim(path_plasma_output, delim = ",", x = scfa_plasma_dedup)

## READ IN FECAL SCFA ==========================================================
fecal_scfas <- readr::read_delim(path_fecal_input, delim = ",", col_types = "fdddd") %>% dplyr::select(., -butyrate)
new_fecal_butyrate <- readr::read_delim(path_new_but_isobut, delim = ",", col_types = "fdd")
fecal_scfas <- merge(new_fecal_butyrate, fecal_scfas, by = "subject_id")
fecal_scfas <- fecal_scfas %>% rename(., "butyrate" = "new_butyrate", "isobutyrate" = "new_isobutyrate")
fecal_vars <- read.delim(path_fecal_vars)

## get rid of fecal samples that are >24 hrs or after visit 1
fecal_vars <- fecal_vars %>%
  dplyr::filter(., diff_time_hrs < 24) %>%
  dplyr::filter(., AfterV2 == 0)

fecal_scfas <- fecal_scfas %>% dplyr::filter(., subject_id %in% fecal_vars$subject_id)

## take relative abundane of SCFA
fecal_scfas$acetate_norm <- fecal_scfas$acetate / fecal_scfas$total_scfa
fecal_scfas$butyrate_norm <- fecal_scfas$butyrate / fecal_scfas$total_scfa
fecal_scfas$propionate_norm <- fecal_scfas$propionate / fecal_scfas$total_scfa

## dist to norm (60:20:20)
fecal_scfas$acetate_norm_ratio_dist <- fecal_scfas$acetate_norm - 0.6
fecal_scfas$butyrate_norm_ratio_dist <- fecal_scfas$butyrate_norm - 0.2
fecal_scfas$propionate_norm_ratio_dist <- fecal_scfas$propionate_norm - 0.2

## get rid of isobutyrate - further evidence makes it seem like it is not isobutyrate
fecal_scfas <- fecal_scfas %>% dplyr::select(., -isobutyrate)

#readr::write_delim(path_fecal_output, delim = ",", x = fecal_scfas)

```

### Filtering and editing Andrew's SCFA tables
```{r edit_scfa_tbl}
# filter scfa table, change subject_id data type from factor to character, and rename headers
f_scfas = fecal_scfas[,c(1:8)]
f_scfas$subject_id = as.character(f_scfas$subject_id)

colnames(f_scfas) = 
  c(
    "subject_id", 
    "f_butyrate_nm_abs", 
    "f_acetate_nm_abs", 
    "f_propionate_nm_abs", 
    "f_AcPrBu_tot_nm_abs", 
    "f_acetate_nm_rel", 
    "f_butyrate_nm_rel", 
    "f_propionate_nm_rel"
    )


p_scfa_dedup = scfa_plasma_dedup
p_scfa_dedup$subject_id = as.character(p_scfa_dedup$subject_id)

colnames(p_scfa_dedup) = 
  c(
    "subject_id", 
    "p_acetic_mg_abs", 
    "p_propionic_mg_abs", 
    "p_butyric_mg_abs", 
    "p_butyric_nm_abs", 
    "p_acetic_nm_abs", 
    "p_propionic_nm_abs", 
    "p_AcPrBu_tot_nm_abs", 
    "p_butyric_nm_rel", 
    "p_acetic_nm_rel", 
    "p_propionic_nm_rel"
    )


class(p_scfa_dedup)
class(f_scfas)
```

----

### Join the pathways and genes RPKG lists, respectively, with the butyrate concentration data
Use `inner_join()` because I only want subjects that have pathway RPKG **and** butyrate measurements, because not all subjects were metagenome'd and GC/MS'd
```{r join_rpkg_conc}
path_and_conc <- list()

for (element_name in names(pathways_rpkg)) {
  
  # Inner join with `f_scfas` and store the result with "f_" prefix
  path_and_conc[[paste0("f_", element_name)]] <- 
    inner_join(f_scfas, pathways_rpkg[[element_name]], by = "subject_id")
  
  # Inner join with `p_scfa_dedup` and store the result with "p_" prefix
  path_and_conc[[paste0("p_", element_name)]] <- 
    inner_join(p_scfa_dedup, pathways_rpkg[[element_name]], by = "subject_id")
}


genes_and_conc <- list()

for (element_name in names(genes_rpkg)) {
  
  # Inner join with `f_scfas` and store the result with "f_" prefix
  genes_and_conc[[paste0("f_", element_name)]] <- 
    inner_join(f_scfas, genes_rpkg[[element_name]], by = "subject_id")
  
  # Inner join with `p_scfa_dedup` and store the result with "p_" prefix
  genes_and_conc[[paste0("p_", element_name)]] <- 
    inner_join(p_scfa_dedup, genes_rpkg[[element_name]], by = "subject_id")
}

# Check the names of the new list
names(path_and_conc)
head(path_and_conc[["f_d90"]])
names(genes_and_conc)
head(genes_and_conc[["f_d90"]])
nrow(path_and_conc[["f_d90"]]) 
nrow(genes_and_conc[["f_d90"]])

```

### Scatter plot of butyrate *pathway* RPKG vs fecal butyrate concentration
```{r fecal_scatter}
f_names <- grep("^f_", names(path_and_conc), value = TRUE)

legend_order <- c(
  # "f_d100",
  "f_d99", 
  # "f_d98",
  # "f_d95",
  #"f_d90", 
  # "f_d80",
  # "f_d70",
  # "f_d60",
  "f_d50", 
  "f_d90_b", 
  # "f_d80_b",
  # "f_d70_b",
  # "f_d60_b",
  "f_d50_b", 
  #"f_d40_b", 
  # "f_d90_b_m",
  "f_hGA_b",
  "f_hGA_b_fs"
  #"f_hGA_b_m"
  )

custom_colors <- c(
  # "f_d100" = "darkblue",
  "f_d99" = "black",
  # "f_d98" = "purple4",
  # "f_d95" = "purple",
  #"f_d90" = "grey30",
  # "f_d80" = "black",
  # "f_d70" = "grey30",
  # "f_d60" = "grey60",
  "f_d50" = "cyan",
  "f_d90_b" = "purple",
  # "f_d80_b" = "blue",
  # "f_d70_b" = "purple4",
  # "f_d60_b" = "black",
  "f_d50_b" = "orange",
  #"f_d40_b" = "yellow",
  # "f_d90_b_m" = "green",
  "f_hGA_b" = "blue",
  "f_hGA_b_fs" = "red"
  #"f_hGA_b_m" = "cyan"
  )

# Define your variable lists
#pathway_graphs <- c("Acetyl", "Lys", "GABA", "Glut", "sumPaths1", "sumPaths2")
pathway_graphs <- c("Acetyl", "sumPaths1", "sumPaths2")
conc_graphs <- c("f_butyrate_nm_abs", "f_butyrate_nm_rel")

# Create a list to store the plots
plot_list <- list()

# Nested loops to iterate over combinations of pathway and concentration graphs
for (pathway_var in pathway_graphs) {
  for (conc_var in conc_graphs) {
    
    combined_data <- do.call(rbind, lapply(legend_order, function(merged_element) {
      data <- path_and_conc[[merged_element]]
      data %>%
        select(subject_id, all_of(c(pathway_var, conc_var))) %>% # Select the relevant columns
        mutate(Element = merged_element)                    # Add a column to identify the source element
    }))
    
    # Set factor levels for the Element column to control legend order
    combined_data$Element <- factor(combined_data$Element, levels = legend_order)
    
    # Create the plot title dynamically
    plot_title <- paste(conc_var, "vs", pathway_var)
    
    # Create the ggplot object
    p <- ggplot(combined_data, aes(x = !!sym(pathway_var), y = !!sym(conc_var), color = Element)) +
      geom_point(size = 0.8) +
      geom_smooth(method = "lm", se = TRUE, alpha = 0.20, linewidth = 1.0) +
      labs(x = "pathway", y = "nanomolarity", title = plot_title, color = "Workflow") +
      scale_color_manual(values = custom_colors) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5),  # Center the plot title
      )
    
    # Store the plot in the list with a descriptive name
    plot_list[[paste(conc_var, pathway_var, sep = "_vs_")]] <- p
  }
}

# Print the plots
plot_list
```

### Scatter plots of butyrate *pathway* RPKG vs plasma butyrate concentration
```{r plasma_scatter}
p_names <- grep("^p_", names(path_and_conc), value = TRUE)

pathways <- colnames(pathways_rpkg[[1]])[colnames(pathways_rpkg[[1]]) != "subject_id"]

legend_order <- c(
  #"p_d100", 
  #"p_d99", 
  #"p_d98", 
  #"p_d95", 
  "p_d50", 
  #"p_d60", 
  #"p_d70", 
  #"p_d80", 
  "p_d90", 
  "p_d90_b", 
  #"p_d80_b", 
  #"p_d70_b", 
  #"p_d60_b", 
  "p_d50_b", 
  #"p_d40_b", 
  "p_d90_b_m", 
  "p_hGA_b", 
  "p_hGA_b_fs"
  #"p_hGA_b_m"
)

custom_colors <- 
  c(
    
    #"p_d100" = "black", 
    #"p_d99" = "grey30", 
    #"p_d98" = "grey60",
    #"p_d95" = "grey90", 
    "p_d50" = "grey", 
    #"p_d60" = "blue", 
    #"p_d70" = "blue", 
    #"p_d80" = "blue", 
    "p_d90" = "grey30", 
    "p_d90_b" = "black", 
    #"p_d80_b" = "grey30", 
    #"p_d70_b" = "grey60",
    #"p_d60_b" = "grey90", 
    "p_d50_b" = "blue", 
    #"p_d40_b" = "orange", 
    "p_d90_b_m" = "red", 
    "p_hGA_b" = "green", 
    "p_hGA_b_fs" = "hotpink" 
    #"p_hGA_b_m" = "cyan"
    )

# Define your variable lists
pathway_graphs <- c("Acetyl", "sumPaths1", "sumPaths2")
conc_graphs <- c("p_butyric_nm_abs", "p_butyric_nm_rel")

# Create a list to store the plots
plot_list <- list()

# Nested loops to iterate over combinations of pathway and concentration graphs
for (pathway_var in pathway_graphs) {
  for (conc_var in conc_graphs) {
    
    combined_data <- do.call(rbind, lapply(p_names, function(merged_element) {
      data <- path_and_conc[[merged_element]]
      data %>%
        select(subject_id, all_of(c(pathway_var, conc_var))) %>% # Select the relevant columns
        mutate(Element = merged_element)                    # Add a column to identify the source element
    }))
    
    # Set factor levels for the Element column to control legend order
    combined_data$Element <- factor(combined_data$Element, levels = legend_order)

    # Create the plot title dynamically
    plot_title <- paste(conc_var, "vs", pathway_var, "for All Elements with Trendlines")
    
    # Create the ggplot object
    p <- ggplot(combined_data, aes(x = !!sym(pathway_var), y = !!sym(conc_var), color = Element)) +
      geom_point(size = 0.8) +
      geom_smooth(method = "lm", se = TRUE, alpha = 0.20, linewidth = 1.0) +
      labs(x = "pathway", y = "nanomolarity", title = plot_title, color = "Workflow") +
      scale_color_manual(values = custom_colors) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5),  # Center the plot title
      )
    
    # Store the plot in the list with a descriptive name
    plot_list[[paste(conc_var, pathway_var, sep = "_vs_")]] <- p
  }
}

# Print the plots
plot_list
```

- plasma butyrate concentration doesn't correlate with genes RPKG

<br>

### Correlating butyrate *pathway* RPKG vs fecal butyrate concentration
```{r corr_path_and_fecal}
f_names <- grep("^f_", names(path_and_conc), value = TRUE)
# Define your variable lists
pathway_graphs <- c("Acetyl", "Lys", "GABA", "Glut", "sumPaths1", "sumPaths2")
conc_graphs <- c("f_butyrate_nm_abs", "f_butyrate_nm_rel")

# Create a data frame to store the correlation results
correlation_results <- data.frame(
  pathway_var = character(),
  conc_var = character(),
  element = character(),
  spearman_rho = numeric(),
  p_value = numeric(),
  stringsAsFactors = FALSE
)

# Nested loops to iterate over combinations of pathway and concentration graphs
for (pathway_var in pathway_graphs) {
  for (conc_var in conc_graphs) {
    
    # Create a combined data frame for each combination
    combined_data <- do.call(rbind, lapply(f_names, function(merged_element) {
      data <- path_and_conc[[merged_element]]
      data %>%
        select(subject_id, !!sym(pathway_var), !!sym(conc_var)) %>% # Select relevant columns using dplyr's non-standard evaluation
        mutate(Element = merged_element)                    # Add a column to identify the source element
    }))
    
    # Calculate Spearman correlation for each element and add to results
    for (element in unique(combined_data$Element)) {
      element_data <- combined_data %>% filter(Element == element)
      
      # Perform Spearman correlation test
      correlation_test <- cor.test(
        element_data[[pathway_var]],
        element_data[[conc_var]],
        method = "spearman",
        exact = FALSE,
        use = "complete.obs"
      )
      
      # Store the results in the data frame
      correlation_results <- rbind(
        correlation_results,
        data.frame(
          pathway_var = pathway_var,
          conc_var = conc_var,
          element = element,
          spearman_rho = correlation_test$estimate,
          p_value = correlation_test$p.value,
          stringsAsFactors = FALSE
        )
      )
      
      rownames(correlation_results) <- NULL
    }
  }
}
correlation_results %>%
  filter(p_value < 0.05) %>%
  mutate(
    spearman_rho = round(spearman_rho, 3),
    p_value = round(p_value, 4)
  ) %>%
  arrange(desc(spearman_rho))

```

### Correlating butyrate *pathway* RPKG vs <u>plasma</u> butyrate concentration
```{r corr_path_and_plasma, echo=FALSE}
f_names <- grep("^p_", names(path_and_conc), value = TRUE)
# Define your variable lists
pathway_graphs <- c("Acetyl", "Lys", "GABA", "Glut", "sumPaths1", "sumPaths2")
conc_graphs <- c("p_butyric_nm_abs", "p_butyric_nm_rel")

# Create a data frame to store the correlation results
correlation_results <- data.frame(
  pathway_var = character(),
  conc_var = character(),
  element = character(),
  spearman_rho = numeric(),
  p_value = numeric(),
  stringsAsFactors = FALSE
)

# Nested loops to iterate over combinations of pathway and concentration graphs
for (pathway_var in pathway_graphs) {
  for (conc_var in conc_graphs) {
    
    # Create a combined data frame for each combination
    combined_data <- do.call(rbind, lapply(f_names, function(merged_element) {
      data <- path_and_conc[[merged_element]]
      data %>%
        select(subject_id, !!sym(pathway_var), !!sym(conc_var)) %>% # Select relevant columns using dplyr's non-standard evaluation
        mutate(Element = merged_element)                    # Add a column to identify the source element
    }))
    
    # Calculate Spearman correlation for each element and add to results
    for (element in unique(combined_data$Element)) {
      element_data <- combined_data %>% filter(Element == element)
      
      # Perform Spearman correlation test
      correlation_test <- cor.test(
        element_data[[pathway_var]],
        element_data[[conc_var]],
        method = "spearman",
        exact = FALSE,
        use = "complete.obs"
      )
      
      # Store the results in the data frame
      correlation_results <- rbind(
        correlation_results,
        data.frame(
          pathway_var = pathway_var,
          conc_var = conc_var,
          element = element,
          spearman_rho = correlation_test$estimate,
          p_value = correlation_test$p.value,
          stringsAsFactors = FALSE
        )
      )
      
      rownames(correlation_results) <- NULL
    }
  }
}
correlation_results %>%
  filter(p_value < 0.05) %>%
  mutate(
    spearman_rho = round(spearman_rho, 3),
    p_value = round(p_value, 4)
  ) %>%
  arrange(desc(spearman_rho))

```
- plasma butyric acid doesn't correlate with any pathway RPKG

### Correlating butyrate pathway *gene* RPKG vs fecal butyrate concentration
```{r corr_gene_and_fecal}
f_names <- grep("^f_", names(path_and_conc), value = TRUE)
# Define your variable lists
pathway_graphs <- c(
           "abfH", # beginning of 4-aminobutyrate pathway
           "ghbt", 
           "abfD", 
           "kamA", # beginning of lysine pathway
           "kamD", 
           "kamE", 
           "kdd", 
           "kce", 
           "kal", 
           "atoA", 
           "atoD", 
           "gctA", # beginning of Glutarate pathway
           "gctB", 
           "hgCoAdA", 
           "hgCoAdB", 
           "hgCoAdC", 
           "gcdA", 
           "gcdB", ## note that this gene is not included in the pathway calculations
           "but", # beginning of acetyl-CoA pathway
           "buk", 
           "ptb", 
           "thl", 
           "bhbd", 
           "cro",
           "bcd", # shared genes
           "etfA", 
           "etfB"
           )
conc_graphs <- c("f_butyrate_nm_abs", "f_butyrate_nm_rel")

# Create a data frame to store the correlation results
correlation_results2 <- data.frame(
  pathway_var = character(),
  conc_var = character(),
  element = character(),
  spearman_rho = numeric(),
  p_value = numeric(),
  stringsAsFactors = FALSE
)

# Nested loops to iterate over combinations of pathway and concentration graphs
for (pathway_var in pathway_graphs) {
  for (conc_var in conc_graphs) {
    
    # Create a combined data frame for each combination
    combined_data <- do.call(rbind, lapply(f_names, function(merged_element) {
      data <- genes_and_conc[[merged_element]]
      data %>%
        select(subject_id, !!sym(pathway_var), !!sym(conc_var)) %>% # Select relevant columns using dplyr's non-standard evaluation
        mutate(Element = merged_element)                    # Add a column to identify the source element
    }))
    
    # Calculate Spearman correlation for each element and add to results
    for (element in unique(combined_data$Element)) {
      element_data <- combined_data %>% filter(Element == element)
      
      # Perform Spearman correlation test
      correlation_test <- cor.test(
        element_data[[pathway_var]],
        element_data[[conc_var]],
        method = "spearman",
        exact = FALSE,
        use = "complete.obs"
      )
      
      # Store the results in the data frame
      correlation_results2 <- rbind(
        correlation_results2,
        data.frame(
          pathway_var = pathway_var,
          conc_var = conc_var,
          element = element,
          spearman_rho = correlation_test$estimate,
          p_value = correlation_test$p.value,
          stringsAsFactors = FALSE
        )
      )
    }
  }
}
correlation_results2 %>%
  filter(p_value < 0.05) %>%
  mutate(
    spearman_rho = round(spearman_rho, 3),
    p_value = round(p_value, 4)
  ) %>%
  arrange(desc(spearman_rho))

```
- the relative abundance of butyrate correlates much more strongly than the absolute abundance
- the standard Lemay workflow for calculating RPKG of metagenome genes gives the best correlations
  - 95% identity cutoff seems to be the most correlated
- **etfA**, **bhbd**, **thl**, **etfB**, **but**, **bcd**, and **cro** are the best-correlated genes. 
  - **etfA**, **etfB**, and **bcd** are the genes common to all pathways, but the sum of their RPKG is not better than the genes individually (data not shown)
    - **etfA**, **bhbd**, **thl**, **etfB**, **but**, and **bcd** more strongly correlate with the concentration of butyrate than any of the pathway calculations
  - **bhbd**, **thl**, and **cro** are common to the Acetyl-CoA pathways, and **but** is one of the possible terminal genes for Acetyl-CoA pathways. **buk** is the other and is less common, so it makes sense it is not a top correlator


### Correlating butyrate pathway *gene* RPKG vs <u>plasma</u> butyrate concentration
```{r corr_gene_and_plasma, echo=FALSE, message=FALSE, warning=FALSE}
f_names <- grep("^p_", names(path_and_conc), value = TRUE)
# Define your variable lists
pathway_graphs <- c(
           "abfH", # beginning of 4-aminobutyrate pathway
           "ghbt", 
           "abfD", 
           "kamA", # beginning of lysine pathway
           "kamD", 
           "kamE", 
           "kdd", 
           "kce", 
           "kal", 
           "atoA", 
           "atoD", 
           "gctA", # beginning of Glutarate pathway
           "gctB", 
           "hgCoAdA", 
           "hgCoAdB", 
           "hgCoAdC", 
           "gcdA", 
           "gcdB", ## note that this gene is not included in the pathway calculations
           "but", # beginning of acetyl-CoA pathway
           "buk", 
           "ptb", 
           "thl", 
           "bhbd", 
           "cro",
           "bcd", # shared genes
           "etfA", 
           "etfB"
           )
conc_graphs <- c("p_butyric_nm_abs", "p_butyric_nm_rel")

# Create a data frame to store the correlation results
correlation_results2 <- data.frame(
  pathway_var = character(),
  conc_var = character(),
  element = character(),
  spearman_rho = numeric(),
  p_value = numeric(),
  stringsAsFactors = FALSE
)

# Nested loops to iterate over combinations of pathway and concentration graphs
for (pathway_var in pathway_graphs) {
  for (conc_var in conc_graphs) {
    
    # Create a combined data frame for each combination
    combined_data <- do.call(rbind, lapply(f_names, function(merged_element) {
      data <- genes_and_conc[[merged_element]]
      data %>%
        select(subject_id, !!sym(pathway_var), !!sym(conc_var)) %>% # Select relevant columns using dplyr's non-standard evaluation
        mutate(Element = merged_element)                    # Add a column to identify the source element
    }))
    
    # Calculate Spearman correlation for each element and add to results
    for (element in unique(combined_data$Element)) {
      element_data <- combined_data %>% filter(Element == element)
      
      # Perform Spearman correlation test
      correlation_test <- cor.test(
        element_data[[pathway_var]],
        element_data[[conc_var]],
        method = "spearman",
        exact = FALSE,
        use = "complete.obs"
      )
      
      # Store the results in the data frame
      correlation_results2 <- rbind(
        correlation_results2,
        data.frame(
          pathway_var = pathway_var,
          conc_var = conc_var,
          element = element,
          spearman_rho = correlation_test$estimate,
          p_value = correlation_test$p.value,
          stringsAsFactors = FALSE
        )
      )
    }
  }
}
correlation_results2 %>%
  filter(p_value < 0.05) %>%
  mutate(
    spearman_rho = round(spearman_rho, 3),
    p_value = round(p_value, 4)
  ) %>%
  arrange(desc(spearman_rho))

```
- most likely these correlations are spurious

<br>
